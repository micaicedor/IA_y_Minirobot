# -*- coding: utf-8 -*-
"""Prediccion_Flores.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1V-Pa8GIlsO_dxfQ8xVet-kPY82Qo7xrG
"""

import tensorflow as tf
import tensorflow_datasets as tfds
import matplotlib.pyplot as plt
import numpy as np

# 1. Cargar dataset
(ds_train, ds_test), ds_info = tfds.load(
    "tf_flowers",
    split=["train[:80%]", "train[80%:]"],
    as_supervised=True,
    with_info=True
)

# Función para redimensionar (para el modelo)
def format_image(image, label):
    image = tf.image.resize(image, (64, 64)) / 255.0
    return image, label

ds_train = ds_train.map(format_image).batch(32).shuffle(1000)
ds_test = ds_test.map(format_image).batch(32)

# 2. Clases desde el dataset
class_names = ds_info.features["label"].names
print("Clases detectadas:", class_names)

# 3. Modelo
model = tf.keras.Sequential([
    tf.keras.layers.Flatten(input_shape=(64, 64, 3)),
    tf.keras.layers.Dense(128, activation="relu"),
    tf.keras.layers.Dense(64, activation="relu"),
    tf.keras.layers.Dense(len(class_names), activation="softmax")
])

model.compile(optimizer="adam",
              loss="sparse_categorical_crossentropy",
              metrics=["accuracy"])

# 4. Entrenar
history = model.fit(ds_train, validation_data=ds_test, epochs=100)


# 5. Probar con una imagen del dataset original (no redimensionada)
raw_test = tfds.load("tf_flowers", split="train[80%:]", as_supervised=True)  # dataset original

# 6. Graficar Accuracy y Loss
plt.figure(figsize=(12,5))

plt.figure(figsize=(8,6))
plt.plot(history.history['accuracy'], label='Accuracy')
plt.plot(history.history['loss'], label='Loss')
plt.xlabel('Épocas')
plt.ylabel('Valor')
plt.title('Accuracy vs Loss durante el entrenamiento')
plt.legend()
plt.show()

for i, (orig_img, orig_label) in enumerate(raw_test):
    if i == 4:
        # Copia procesada para el modelo
        img_proc = tf.image.resize(orig_img, (64, 64)) / 255.0
        img_proc = np.expand_dims(img_proc, axis=0)

        # Predicción
        prediction = model.predict(img_proc)[0]

        # Mostrar la imagen original (sin pixelar)
        plt.imshow(orig_img.numpy().astype("uint8"))
        plt.axis("off")
        plt.show()

        # Clase real y predicha
        real_class = class_names[orig_label.numpy()]
        predicted_class = class_names[np.argmax(prediction)]

        print("\nClase real:", real_class)
        print("Clase predicha:", predicted_class)

"""#Resultados
Tras el entrenamiento, el modelo alcanzó un porcentaje de precisión aceptable en la clasificación de las flores. No obstante, debido a que la red estaba compuesta únicamente por tres capas densas, su capacidad de representación era limitada frente a la complejidad de las imágenes a color.
Como consecuencia, el modelo necesitó aproximadamente 100 iteraciones para obtener resultados satisfactorios. Esto evidencia que, aunque fue capaz de aprender patrones
"""